Fragen für 2.5:


5. SAT test --> vampire.Tptp


- in Algorithmus: C_0 \cup {regr_a(\lnot co)}
        --> C_0 ist liste von Atomen, x = regr_a() ist Conjunction
        --> dann x in list umwandeln, set() und dann wieder in Conjunction? (damit formula)

Task hat predicates on, handempty, holding, etc.
predicates haben Menge and objekten (0 für handempty, 1 für holding, 2 für on)
Task hat objekte a, b, c, d
Task predicates haben objekte ?x, ?y

im moment C_0 und C sind listen von Atomen in jeglicher Kombination: on(?x, ?y), on(?x, a), on(a, b), holding(?x), holding(a) etc.

sollten C_0 und C Conjunctions sein oder Listen? --> im Falle von Union: werden zwei Listen verknüpft oder zwei Formeln



für weaken: Let A be set of state variables. 1. a and \lnot a for state variables a \in A are effects
--> weaken clause: {c v a | a in A} U {c v !a | a in A}
--> ist nun a in c v a ein effect oder eine State variable? falls state variable: was ist das in meinem Fall



Fragen für 2.5:

1. Kontrolle invariant candidates
2. C_0: list oder conjunction? union() --> liste oder conjunction
3. SAT test
4. weaken: list/conjunction thema und action/effect kontrolle
5. betreffend c sigma: welche kombinationen fehlen, welche muss ich noch machen (evt invariant candidates von anfang an schwächen)


- in Algorithmus: C_0 \cup {regr_a(\lnot co)}
        --> C_0 ist liste von Atomen, x = regr_a() ist Conjunction
        --> dann x in list umwandeln, set() und dann wieder in Conjunction? (damit formula)

Task hat predicates on, handempty, holding, etc.
predicates haben Menge and objekten (0 für handempty, 1 für holding, 2 für on)
Task hat objekte a, b, c, d
Task predicates haben objekte ?x, ?y

im moment C_0 und C sind listen von Atomen in jeglicher Kombination: on(?x, ?y), on(?x, a), on(a, b), holding(?x), holding(a) etc.

sollten C_0 und C Conjunctions sein oder Listen? --> im Falle von Union: werden zwei Listen verknüpft oder zwei Formeln



für weaken: Let A be set of state variables. 1. a and \lnot a for state variables a \in A are effects
--> weaken clause: {c v a | a in A} U {c v !a | a in A}
--> ist nun a in c v a ein effect oder eine State variable? falls state variable: was ist das in meinem Fall

/home/lukas/git/downward-benchmarks/blocks/domain.pddl /home/lukas/git/downward-benchmarks/blocks/probBLOCKS-4-0.pddl --search "astar(lmcut())"


  Disjunction
    Atom clear(c)
    Atom clear(d)
    Atom handempty(z)
    Atom holding(a)
    Atom ontable(b)
    Atom holding(d)
    Atom ontable(d)
    Atom ontable(a)
    Atom ontable(c)
    Atom holding(c)
    Atom on(d, c)
    Atom clear(b)
    Atom on(d, b)
  Disjunction
    Atom clear(b)
    Atom clear(d)
    Atom holding(b)
    Atom holding(a)
    Atom ontable(d)
    Atom ontable(c)
    Atom handempty(z)
    Atom on(a, c)
    Atom holding(c)
    Atom clear(a)
    Atom on(a, b)
    Atom on(d, a)
    Atom on(c, d)
    Atom on(d, b)
    Atom clear(c)
  Disjunction
    Atom ontable(a)
    Atom ontable(d)
    Atom handempty(z)
    Atom holding(a)
    Atom on(c, a)
    Atom holding(b)
    Atom on(a, b)
    Atom on(a, d)
    Atom clear(c)
    Atom clear(a)
    Atom holding(d)
    Atom clear(b)
    Atom on(c, d)
    Atom on(d, b)
    Atom holding(c)
    Atom on(b, c)
  Disjunction
    Atom ontable(b)
    Atom ontable(d)
    Atom clear(c)
    Atom holding(a)
    Atom on(d, a)
    Atom ontable(a)
    Atom holding(c)
    Atom clear(d)
    Atom ontable(c)
    Atom on(a, c)
    Atom holding(b)
    Atom on(c, d)
    Atom handempty(z)
    Atom clear(a)
    Atom holding(d)
    Atom on(b, c)
  Disjunction
    Atom handempty(z)
    NegatedAtom handempty(z)
    Atom clear(b)
    Atom ontable(a)
    Atom on(d, c)
    Atom handempty(z)
    Atom on(b, c)
    Atom clear(c)
    Atom clear(a)
    Atom ontable(d)
    Atom clear(d)
  Disjunction
    Atom ontable(c)
    Atom ontable(d)
    Atom on(c, b)
    Atom holding(c)
    Atom handempty(z)
    Atom on(a, c)
    Atom holding(d)
    Atom on(d, a)
    Atom clear(d)
    Atom holding(a)
    Atom clear(a)
    Atom ontable(b)
    Atom clear(b)
    Atom clear(c)
  Disjunction
    Atom clear(a)
    Atom clear(d)
    Atom holding(d)
    Atom holding(c)
    Atom handempty(z)
    Atom ontable(d)
    Atom on(c, d)
    Atom on(b, d)
    Atom holding(a)
    Atom ontable(c)
    Atom on(b, c)
    Atom clear(b)
    Atom holding(b)
    Atom clear(c)
  Disjunction
    Atom ontable(d)
    Atom ontable(b)
    Atom holding(c)
    Atom on(b, c)
    Atom handempty(z)
    Atom holding(d)
    Atom clear(a)
    Atom on(a, b)
    Atom holding(b)
    Atom on(b, d)
    Atom ontable(c)
    Atom holding(a)
    Atom clear(c)
    Atom on(c, a)
    Atom on(c, b)
    Atom ontable(a)
    Atom on(a, c)
    Atom clear(b)
    Atom on(d, c)
  Disjunction
    Atom clear(d)
    Atom clear(b)
    Atom on(a, c)
    Atom ontable(c)
    Atom handempty(z)
    Atom holding(a)
    Atom on(a, b)
    Atom on(b, c)
    Atom holding(c)
    Atom ontable(a)
    Atom on(b, d)
    Atom ontable(d)
    Atom on(b, a)
    Atom on(c, a)
    Atom clear(a)
    Atom on(d, a)
    Atom ontable(b)
    Atom clear(c)


def create_invariant_candidates1(task):
    inv_list = []
    name_arg_list = []
    for pred in task.predicates:
        if pred.name != "=":
            arg_list = []
            for arg in pred.arguments:
                arg_list.append(arg.name)
            name_arg_list.append((pred.name, arg_list))
    obj_list = []
    for obj in task.objects:
        obj_list.append(obj.name)
    for (name, args) in name_arg_list:
        if len(args) == 0:
            inv_list.append(Atom(predicate=name, args=["z"]))
        elif len(args) == 1:
            inv_list.append(Atom(predicate=name, args=[args[0]]))
            for obj in obj_list:
                inv_list.append(Atom(predicate=name, args=obj))
        else:
            for obj in obj_list:
                for arg in args:
                    inv_list.append(Atom(predicate=name, args=[obj, arg]))
                    inv_list.append(Atom(predicate=name, args=[arg, obj]))
                    for arg1 in args:
                        if arg != arg:
                            inv_list.append(Atom(predicate=name, args=[arg, arg1]))
                            inv_list.append(Atom(predicate=name, args=[arg1, arg]))
                for obj1 in obj_list:
                    if obj != obj1:
                        inv_list.append(Atom(predicate=name, args=[obj1, obj]))
                        inv_list.append(Atom(predicate=name, args=[obj, obj1]))
    # TODO: X -> l_1 \lor l_2 richtig?
    temp_inv_list = []
    for inv in inv_list:
        for inv1 in inv_list:
            if inv != inv1:
                temp_inv_list.append(Disjunction([inv, inv1]))
    return inv_list